<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>Triangle Test - WebGPU</title>
    <style>
        html, body {
            background: #000;
            height: 100%;
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
            height: 100vh;
            width: 100vw;
        }
    </style>
</head>
<body>
<canvas id="c"></canvas>
<script type="module">
const canvas = document.getElementById("c");

const adapter = await navigator.gpu.requestAdapter();
const device = await adapter.requestDevice();
const context = canvas.getContext("webgpu");
const format = navigator.gpu.getPreferredCanvasFormat();

// Equilateral triangle, side length 1, centered
const h = Math.sqrt(3) / 2;
const yTop = h * 2/3; 
const yBot = -h * 1/3;

const vertices = new Float32Array([
    0.0, yTop,
    -0.5, yBot,
    0.5, yBot
]);

const vertexBuffer = device.createBuffer({
    size: vertices.byteLength,
    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
});
device.queue.writeBuffer(vertexBuffer, 0, vertices);

// Uniform buffer for aspect ratio
const uniformBuffer = device.createBuffer({
    size: 4, // 1 float
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
});

const shader = device.createShaderModule({
    code: `
        struct Uniforms {
                aspect: f32,
        };
        @group(0) @binding(0) var<uniform> u: Uniforms;

        @vertex
        fn vs(@location(0) pos: vec2f) -> @builtin(position) vec4f {
                return vec4f(pos.x / u.aspect, pos.y, 0.0, 1.0);
        }

        @fragment
        fn fs() -> @location(0) vec4f {
                return vec4f(1.0, 0.0, 0.0, 1.0);
        }
    `
});

const pipeline = device.createRenderPipeline({
    layout: "auto",
    vertex: {
        module: shader,
        entryPoint: "vs",
        buffers: [{
            arrayStride: 8,
            attributes: [{ shaderLocation: 0, format: "float32x2", offset: 0 }]
        }]
    },
    fragment: {
        module: shader,
        entryPoint: "fs",
        targets: [{ format }]
    },
    primitive: { topology: "triangle-list" }
});

const bindGroup = device.createBindGroup({
    layout: pipeline.getBindGroupLayout(0),
    entries: [{
        binding: 0,
        resource: { buffer: uniformBuffer }
    }]
});

function frame() {
    const dpr = window.devicePixelRatio || 1;
    // Update canvas size if needed
    if (canvas.width !== Math.max(1, Math.floor(innerWidth * dpr)) ||
            canvas.height !== Math.max(1, Math.floor(innerHeight * dpr))) {
        canvas.width = Math.max(1, Math.floor(innerWidth * dpr));
        canvas.height = Math.max(1, Math.floor(innerHeight * dpr));
        context.configure({ device, format, alphaMode: "opaque" });
    }

    const aspect = canvas.width / canvas.height;
    device.queue.writeBuffer(uniformBuffer, 0, new Float32Array([aspect]));

    const encoder = device.createCommandEncoder();
    const pass = encoder.beginRenderPass({
        colorAttachments: [{
            view: context.getCurrentTexture().createView(),
            clearValue: { r: 0, g: 0, b: 0, a: 1 },
            loadOp: "clear",
            storeOp: "store"
        }]
    });

    pass.setPipeline(pipeline);
    pass.setBindGroup(0, bindGroup);
    pass.setVertexBuffer(0, vertexBuffer);
    pass.draw(3);
    pass.end();

    device.queue.submit([encoder.finish()]);
    requestAnimationFrame(frame);
}
frame();
</script>
</body>
</html>
